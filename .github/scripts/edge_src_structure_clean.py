#!/usr/bin/env python3
"""
Edge Source Structure Clean Script

This script processes the edge_src_structure_compressed.txt file to:
1. Identify if each line represents a directory or file
2. Keep all directories (unless depth > 15)
3. For files, check if the filename contains more than 2 digits
4. Remove files with more than 2 digits in the filename
5. Remove files/directories with depth > 15
6. Update the original file in place

Features:
- Distinguishes between directories (ending with /) and files
- Keeps directories and files with appropriate criteria
- Removes files with more than 2 digits in filename
- Removes files/directories with depth > 15
- Updates the file in place (no new file created)
- Shows file size before and after processing (in MB)

Author: Generated by GitHub Copilot
Date: June 25, 2025
"""

import re
import os
import tempfile
import shutil
from pathlib import Path


def get_path_depth(line):
    """
    Calculate the depth of a path based on the compressed format
    Format: "N/path/to/file" where N represents the depth level
    
    Args:
        line (str): Line to analyze
        
    Returns:
        int: Depth of the path
    """
    line_clean = line.strip()
    
    # Skip header lines and empty lines
    if line_clean.startswith('#') or not line_clean:
        return 0
    
    # Extract the depth number from the compressed format
    if '/' in line_clean:
        depth_str = line_clean.split('/', 1)[0]
        try:
            base_depth = int(depth_str)
            # Count additional slashes in the path part
            path_part = line_clean.split('/', 1)[1] if len(line_clean.split('/', 1)) > 1 else ""
            additional_depth = path_part.count('/')
            return base_depth + additional_depth
        except ValueError:
            return 0
    
    return 0


def is_directory(line):
    """
    Check if a line represents a directory (ends with /)
    
    Args:
        line (str): Line to check
        
    Returns:
        bool: True if the line represents a directory
    """
    line_clean = line.strip()
    
    # Skip header lines and empty lines
    if line_clean.startswith('#') or not line_clean:
        return False
    
    # Check if it ends with / (indicating a directory)
    return line_clean.endswith('/')


def should_remove_line(line):
    """
    Check if a line should be removed based on the criteria:
    1. Remove files with more than 2 digits in filename
    2. Remove files/directories with depth > 15
    
    Args:
        line (str): Line to check
        
    Returns:
        bool: True if the line should be removed
    """
    # Skip header lines (lines starting with #)
    if line.strip().startswith('#'):
        return False
    
    # Skip empty lines
    if not line.strip():
        return False
    
    line_clean = line.strip()
    
    # Check depth - remove if depth > 15
    depth = get_path_depth(line)
    if depth > 15:
        return True
    
    # If it's a directory, keep it (unless depth > 15, which we already checked)
    if is_directory(line):
        return False
    
    # For files, check digit count in filename
    # Extract the filename from the compressed format
    # Format is typically "N/path/to/file" where N is a number
    if '/' in line_clean:
        # Get the actual filename (last part after the last '/')
        filename = line_clean.split('/')[-1]
    else:
        filename = line_clean
    
    # Count digits in the filename
    digit_count = sum(1 for char in filename if char.isdigit())
    
    # Remove files with MORE than 2 digits (3 or more digits)
    return digit_count > 2


def clean_file(file_path):
    """
    Clean the file by removing:
    1. Files with more than 2 digits in filename
    2. Files/directories with depth > 15
    Keep all other directories and files
    
    Args:
        file_path (str): Path to the file to clean
        
    Returns:
        tuple: (success, lines_removed, original_size_mb, new_size_mb)
    """
    print(f"Starting cleanup of {file_path}...")
    
    # Get original file size
    try:
        original_size = os.path.getsize(file_path)
        original_size_mb = original_size / (1024 * 1024)
    except Exception as e:
        print(f"Error getting original file size: {str(e)}")
        return False, 0, 0, 0
    
    lines_removed = 0
    lines_kept = 0
    total_lines = 0
    directories_kept = 0
    files_kept = 0
    files_removed_digits = 0
    items_removed_depth = 0
    
    try:
        # Create a temporary file to write cleaned content
        temp_file = file_path + '.tmp'
        
        with open(file_path, 'r', encoding='utf-8') as infile, \
             open(temp_file, 'w', encoding='utf-8') as outfile:
            
            for line in infile:
                total_lines += 1
                
                # Check if this line should be removed
                if should_remove_line(line):
                    lines_removed += 1
                    
                    # Categorize the reason for removal
                    depth = get_path_depth(line)
                    if depth > 15:
                        items_removed_depth += 1
                    else:
                        files_removed_digits += 1
                    
                    # Skip this line (don't write to output)
                    continue
                
                # Write line to output
                outfile.write(line)
                lines_kept += 1
                
                # Count directories vs files
                if is_directory(line):
                    directories_kept += 1
                elif line.strip() and not line.strip().startswith('#'):
                    files_kept += 1
                
                # Print progress for large files
                if total_lines % 100000 == 0:
                    print(f"Processed {total_lines:,} lines, kept {lines_kept:,}, removed {lines_removed:,}...")
        
        # Replace original file with cleaned version
        shutil.move(temp_file, file_path)
        
        # Get new file size
        new_size = os.path.getsize(file_path)
        new_size_mb = new_size / (1024 * 1024)
        
        print(f"\nProcessing complete:")
        print(f"- Directories kept: {directories_kept:,}")
        print(f"- Files kept: {files_kept:,}")
        print(f"- Files removed (>2 digits): {files_removed_digits:,}")
        print(f"- Items removed (depth >15): {items_removed_depth:,}")
        print(f"- Total removed: {lines_removed:,}")
        
        return True, lines_removed, original_size_mb, new_size_mb
        
    except FileNotFoundError:
        print(f"Error: File '{file_path}' not found!")
        return False, 0, 0, 0
    except Exception as e:
        print(f"Error during cleanup: {str(e)}")
        # Clean up temp file if it exists
        temp_file = file_path + '.tmp'
        if os.path.exists(temp_file):
            os.remove(temp_file)
        return False, 0, 0, 0


def main():
    """Main function to execute the cleanup"""
    # Use the absolute path as specified in the requirements
    target_file = "/Users/pumpedgechina/repos/Prompts/.outputs/edge_src_structure_compressed.txt"
    
    print("Edge Source Structure Clean Tool")
    print("=" * 50)
    print(f"Target file: {target_file}")
    print("Task: Remove files with more than 2 digits in filename")
    print("      Remove files/directories with depth > 15")
    print("      Keep all other directories and files")
    print()
    
    # Check if target file exists
    if not os.path.exists(target_file):
        print(f"Error: Target file '{target_file}' does not exist!")
        return
    
    # Perform cleanup
    success, lines_removed, original_size_mb, new_size_mb = clean_file(target_file)
    
    if success:
        print(f"\nCleanup completed successfully!")
        print(f"Total lines removed: {lines_removed:,}")
        print(f"Original file size: {original_size_mb:.2f} MB")
        print(f"New file size: {new_size_mb:.2f} MB")
        
        size_reduction_mb = original_size_mb - new_size_mb
        size_reduction_percent = (size_reduction_mb / original_size_mb) * 100 if original_size_mb > 0 else 0
        
        print(f"Size reduction: {size_reduction_mb:.2f} MB ({size_reduction_percent:.2f}%)")
        print(f"\nFile updated in place: {target_file}")
    else:
        print("\nCleanup failed!")


if __name__ == "__main__":
    main()
