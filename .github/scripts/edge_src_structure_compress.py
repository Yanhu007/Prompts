#!/usr/bin/env python3
"""
Edge Source Structure Compression Script

This script compresses the .outputs/edge_src_structure.txt file by applying
path compression rules and saves the result to .outputs/edge_src_structure_compressed.txt

Compression Method: Path Compression
- Count the number of '../' in the path, assume it's N
- Replace consecutive '../' with 'N/'

Examples:
- ./../ => ./1/
- ./../../ => ./2/
- ./../../../ => ./3/

Author: Generated by GitHub Copilot
Date: June 24, 2025
"""

import re
import os
from pathlib import Path


def compress_path(path_str):
    """
    Compress path by replacing consecutive '../' with 'N/'
    
    Args:
        path_str (str): Original path string
        
    Returns:
        str: Compressed path string
    """
    # Simple approach: replace different patterns based on the test cases
    
    # For patterns starting with './', handle them specially
    if path_str.startswith('./'):
        # Count consecutive '../' after the initial './'
        remaining = path_str[2:]  # Remove initial './'
        
        # Count how many '../' at the beginning
        count = 0
        temp = remaining
        while temp.startswith('../'):
            count += 1
            temp = temp[3:]  # Remove '../'
        
        if count > 0:
            # Replace the '../' sequence with the count
            return f'./{count}/{temp}'
    
    # For other patterns, use regex
    def replace_func(match):
        count = match.group(0).count('../')
        return f'{count}/'
    
    # Replace '../' sequences
    result = re.sub(r'(\.\./)+', replace_func, path_str)
    
    return result


def compress_file(input_file, output_file):
    """
    Compress the input file and save to output file with header
    
    Args:
        input_file (str): Path to input file
        output_file (str): Path to output file
    """
    print(f"Starting compression of {input_file}...")
    
    # Prepare the header with compression method explanation
    header = """# Edge Source Structure - Compressed Version
# 
# Compression Method: Path Compression
# - Count the number of '../' in paths, assume it's N
# - Replace consecutive '../' with 'N/'
# 
# Examples:
# - ./../ => ./1/
# - ./../../ => ./2/  
# - ./../../../ => ./3/
#
# This compression reduces file size while maintaining path structure information.
# To decompress, replace 'N/' patterns back to the corresponding number of '../' sequences.
#
# Generated on: June 24, 2025
# Original file: edge_src_structure.txt
# ================================================================================

"""
    
    line_count = 0
    compressed_count = 0
    
    try:
        with open(input_file, 'r', encoding='utf-8') as infile, \
             open(output_file, 'w', encoding='utf-8') as outfile:
            
            # Write header
            outfile.write(header)
            
            # Process file line by line to handle large files
            for line in infile:
                line_count += 1
                original_line = line.rstrip('\n\r')
                compressed_line = compress_path(original_line)
                
                # Count lines that were actually compressed
                if original_line != compressed_line:
                    compressed_count += 1
                
                outfile.write(compressed_line + '\n')
                
                # Print progress for large files
                if line_count % 10000 == 0:
                    print(f"Processed {line_count:,} lines...")
    
    except FileNotFoundError:
        print(f"Error: Input file '{input_file}' not found!")
        return False
    except Exception as e:
        print(f"Error during compression: {str(e)}")
        return False
    
    print(f"Compression completed successfully!")
    print(f"Total lines processed: {line_count:,}")
    print(f"Lines compressed: {compressed_count:,}")
    print(f"Compression ratio: {(compressed_count/line_count)*100:.2f}%")
    
    # Show file size comparison
    try:
        original_size = os.path.getsize(input_file)
        compressed_size = os.path.getsize(output_file)
        size_reduction = ((original_size - compressed_size) / original_size) * 100
        
        print(f"Original file size: {original_size:,} bytes")
        print(f"Compressed file size: {compressed_size:,} bytes")
        print(f"Size reduction: {size_reduction:.2f}%")
        
    except Exception as e:
        print(f"Could not calculate file size comparison: {str(e)}")
    
    return True


def main():
    """Main function to execute the compression"""
    # Define file paths
    script_dir = Path(__file__).parent
    input_file = script_dir / '.outputs' / 'edge_src_structure.txt'
    output_file = script_dir / '.outputs' / 'edge_src_structure_compressed.txt'
    
    print("Edge Source Structure Compression Tool")
    print("=" * 50)
    print(f"Input file: {input_file}")
    print(f"Output file: {output_file}")
    print()
    
    # Check if input file exists
    if not input_file.exists():
        print(f"Error: Input file '{input_file}' does not exist!")
        return
    
    # Create output directory if it doesn't exist
    output_file.parent.mkdir(parents=True, exist_ok=True)
    
    # Perform compression
    success = compress_file(str(input_file), str(output_file))
    
    if success:
        print(f"\nCompression completed! Output saved to: {output_file}")
    else:
        print("\nCompression failed!")


if __name__ == "__main__":
    main()
